<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>2023年再谈状态管理 | 邢走在云端</title>
    <meta name="generator" content="VuePress 1.5.4">
    <link rel="icon" href="/notes/img/favicon.ico">
    <meta name="description" content="">
    <link rel="preload" href="/notes/assets/css/0.styles.bb774922.css" as="style"><link rel="preload" href="/notes/assets/js/app.660493da.js" as="script"><link rel="preload" href="/notes/assets/js/3.db1e4918.js" as="script"><link rel="preload" href="/notes/assets/js/1.f8ceeabf.js" as="script"><link rel="preload" href="/notes/assets/js/82.f409e717.js" as="script"><link rel="prefetch" href="/notes/assets/js/10.13fadbf7.js"><link rel="prefetch" href="/notes/assets/js/100.f272c3e0.js"><link rel="prefetch" href="/notes/assets/js/101.d101902a.js"><link rel="prefetch" href="/notes/assets/js/102.4d3ffd5a.js"><link rel="prefetch" href="/notes/assets/js/103.fb95cf6f.js"><link rel="prefetch" href="/notes/assets/js/104.22039384.js"><link rel="prefetch" href="/notes/assets/js/105.2bfeb219.js"><link rel="prefetch" href="/notes/assets/js/106.2b1c4fc7.js"><link rel="prefetch" href="/notes/assets/js/107.b879f6b8.js"><link rel="prefetch" href="/notes/assets/js/108.5f8bee0e.js"><link rel="prefetch" href="/notes/assets/js/109.d41bfbb4.js"><link rel="prefetch" href="/notes/assets/js/11.646f9847.js"><link rel="prefetch" href="/notes/assets/js/110.98d17689.js"><link rel="prefetch" href="/notes/assets/js/111.2cdf44b8.js"><link rel="prefetch" href="/notes/assets/js/112.607e03c3.js"><link rel="prefetch" href="/notes/assets/js/113.20e0a8cb.js"><link rel="prefetch" href="/notes/assets/js/114.d0c000a5.js"><link rel="prefetch" href="/notes/assets/js/115.3474965d.js"><link rel="prefetch" href="/notes/assets/js/116.f454220f.js"><link rel="prefetch" href="/notes/assets/js/117.a7799001.js"><link rel="prefetch" href="/notes/assets/js/118.ce17ba40.js"><link rel="prefetch" href="/notes/assets/js/119.6ea7312d.js"><link rel="prefetch" href="/notes/assets/js/12.b7dbc8ca.js"><link rel="prefetch" href="/notes/assets/js/120.b46211ba.js"><link rel="prefetch" href="/notes/assets/js/121.887914cb.js"><link rel="prefetch" href="/notes/assets/js/122.01dcd59f.js"><link rel="prefetch" href="/notes/assets/js/123.7de2a2f5.js"><link rel="prefetch" href="/notes/assets/js/124.87cd489e.js"><link rel="prefetch" href="/notes/assets/js/125.0dc9c4cf.js"><link rel="prefetch" href="/notes/assets/js/126.ee5726fc.js"><link rel="prefetch" href="/notes/assets/js/127.069dd0bd.js"><link rel="prefetch" href="/notes/assets/js/128.050ae877.js"><link rel="prefetch" href="/notes/assets/js/129.2aee00ec.js"><link rel="prefetch" href="/notes/assets/js/13.492e8d0c.js"><link rel="prefetch" href="/notes/assets/js/130.c45ba84b.js"><link rel="prefetch" href="/notes/assets/js/131.74b2a843.js"><link rel="prefetch" href="/notes/assets/js/132.1c21de4d.js"><link rel="prefetch" href="/notes/assets/js/133.d36329d1.js"><link rel="prefetch" href="/notes/assets/js/134.7220eb5e.js"><link rel="prefetch" href="/notes/assets/js/135.6a5d50e0.js"><link rel="prefetch" href="/notes/assets/js/136.f6b78902.js"><link rel="prefetch" href="/notes/assets/js/137.ca510b85.js"><link rel="prefetch" href="/notes/assets/js/138.ec0fbe4a.js"><link rel="prefetch" href="/notes/assets/js/139.60d19f4c.js"><link rel="prefetch" href="/notes/assets/js/14.a4977b0b.js"><link rel="prefetch" href="/notes/assets/js/140.7b105c31.js"><link rel="prefetch" href="/notes/assets/js/141.e0614c7d.js"><link rel="prefetch" href="/notes/assets/js/142.f96ed4e8.js"><link rel="prefetch" href="/notes/assets/js/143.26000528.js"><link rel="prefetch" href="/notes/assets/js/144.d58ad015.js"><link rel="prefetch" href="/notes/assets/js/145.b1442cca.js"><link rel="prefetch" href="/notes/assets/js/146.0a996201.js"><link rel="prefetch" href="/notes/assets/js/147.0f90e9a7.js"><link rel="prefetch" href="/notes/assets/js/148.8873284e.js"><link rel="prefetch" href="/notes/assets/js/149.4af7fd60.js"><link rel="prefetch" href="/notes/assets/js/15.7b876550.js"><link rel="prefetch" href="/notes/assets/js/150.d1d12606.js"><link rel="prefetch" href="/notes/assets/js/151.1abc0ddb.js"><link rel="prefetch" href="/notes/assets/js/152.d1f02f36.js"><link rel="prefetch" href="/notes/assets/js/153.c34d0584.js"><link rel="prefetch" href="/notes/assets/js/154.654d4f6f.js"><link rel="prefetch" href="/notes/assets/js/155.5c7ce623.js"><link rel="prefetch" href="/notes/assets/js/156.f734bb20.js"><link rel="prefetch" href="/notes/assets/js/157.29d37bc6.js"><link rel="prefetch" href="/notes/assets/js/158.0a65ee7c.js"><link rel="prefetch" href="/notes/assets/js/16.8d33f2f9.js"><link rel="prefetch" href="/notes/assets/js/17.0bc994d0.js"><link rel="prefetch" href="/notes/assets/js/18.8b490447.js"><link rel="prefetch" href="/notes/assets/js/19.f6338516.js"><link rel="prefetch" href="/notes/assets/js/20.d37ebfdc.js"><link rel="prefetch" href="/notes/assets/js/21.1f58ec24.js"><link rel="prefetch" href="/notes/assets/js/22.ef7aa250.js"><link rel="prefetch" href="/notes/assets/js/23.c5d63f83.js"><link rel="prefetch" href="/notes/assets/js/24.fc861445.js"><link rel="prefetch" href="/notes/assets/js/25.d7f24b71.js"><link rel="prefetch" href="/notes/assets/js/26.8f7fba05.js"><link rel="prefetch" href="/notes/assets/js/27.67913b3b.js"><link rel="prefetch" href="/notes/assets/js/28.5fa2f80d.js"><link rel="prefetch" href="/notes/assets/js/29.62378c7f.js"><link rel="prefetch" href="/notes/assets/js/30.56de062e.js"><link rel="prefetch" href="/notes/assets/js/31.679e11f3.js"><link rel="prefetch" href="/notes/assets/js/32.7a9e3ea6.js"><link rel="prefetch" href="/notes/assets/js/33.2a6933a1.js"><link rel="prefetch" href="/notes/assets/js/34.aae44348.js"><link rel="prefetch" href="/notes/assets/js/35.036d848b.js"><link rel="prefetch" href="/notes/assets/js/36.2991177b.js"><link rel="prefetch" href="/notes/assets/js/37.e06226c3.js"><link rel="prefetch" href="/notes/assets/js/38.fb7fd573.js"><link rel="prefetch" href="/notes/assets/js/39.0e381f3b.js"><link rel="prefetch" href="/notes/assets/js/4.94f75102.js"><link rel="prefetch" href="/notes/assets/js/40.0059ff7c.js"><link rel="prefetch" href="/notes/assets/js/41.a3d5fb69.js"><link rel="prefetch" href="/notes/assets/js/42.f2344d88.js"><link rel="prefetch" href="/notes/assets/js/43.fdeb9797.js"><link rel="prefetch" href="/notes/assets/js/44.255a8176.js"><link rel="prefetch" href="/notes/assets/js/45.63e1a811.js"><link rel="prefetch" href="/notes/assets/js/46.db035191.js"><link rel="prefetch" href="/notes/assets/js/47.ab65b48a.js"><link rel="prefetch" href="/notes/assets/js/48.748fada5.js"><link rel="prefetch" href="/notes/assets/js/49.1b607427.js"><link rel="prefetch" href="/notes/assets/js/5.1050eaeb.js"><link rel="prefetch" href="/notes/assets/js/50.083d9dd4.js"><link rel="prefetch" href="/notes/assets/js/51.7b02d3f4.js"><link rel="prefetch" href="/notes/assets/js/52.49df9871.js"><link rel="prefetch" href="/notes/assets/js/53.182698c6.js"><link rel="prefetch" href="/notes/assets/js/54.6c8d83be.js"><link rel="prefetch" href="/notes/assets/js/55.32dec22f.js"><link rel="prefetch" href="/notes/assets/js/56.2fbb88c9.js"><link rel="prefetch" href="/notes/assets/js/57.2139baa4.js"><link rel="prefetch" href="/notes/assets/js/58.1d20d529.js"><link rel="prefetch" href="/notes/assets/js/59.6f4d53df.js"><link rel="prefetch" href="/notes/assets/js/6.5a8b595f.js"><link rel="prefetch" href="/notes/assets/js/60.da284af1.js"><link rel="prefetch" href="/notes/assets/js/61.2694299f.js"><link rel="prefetch" href="/notes/assets/js/62.78ce6809.js"><link rel="prefetch" href="/notes/assets/js/63.27def53f.js"><link rel="prefetch" href="/notes/assets/js/64.bb89fe20.js"><link rel="prefetch" href="/notes/assets/js/65.beb33885.js"><link rel="prefetch" href="/notes/assets/js/66.c1791094.js"><link rel="prefetch" href="/notes/assets/js/67.8be12555.js"><link rel="prefetch" href="/notes/assets/js/68.7e7fc60e.js"><link rel="prefetch" href="/notes/assets/js/69.8fae4b5c.js"><link rel="prefetch" href="/notes/assets/js/7.fb60c229.js"><link rel="prefetch" href="/notes/assets/js/70.59d32dba.js"><link rel="prefetch" href="/notes/assets/js/71.f65dd681.js"><link rel="prefetch" href="/notes/assets/js/72.49bdd60b.js"><link rel="prefetch" href="/notes/assets/js/73.f53556c7.js"><link rel="prefetch" href="/notes/assets/js/74.0248fbc8.js"><link rel="prefetch" href="/notes/assets/js/75.7e313c08.js"><link rel="prefetch" href="/notes/assets/js/76.ff01f6c9.js"><link rel="prefetch" href="/notes/assets/js/77.e3be0948.js"><link rel="prefetch" href="/notes/assets/js/78.a0a29531.js"><link rel="prefetch" href="/notes/assets/js/79.12e16726.js"><link rel="prefetch" href="/notes/assets/js/8.2f711b26.js"><link rel="prefetch" href="/notes/assets/js/80.80c8b267.js"><link rel="prefetch" href="/notes/assets/js/81.848f5756.js"><link rel="prefetch" href="/notes/assets/js/83.03fa4cf9.js"><link rel="prefetch" href="/notes/assets/js/84.2004a26b.js"><link rel="prefetch" href="/notes/assets/js/85.c0bb8717.js"><link rel="prefetch" href="/notes/assets/js/86.1204bdfd.js"><link rel="prefetch" href="/notes/assets/js/87.d94ef4a1.js"><link rel="prefetch" href="/notes/assets/js/88.d014fec0.js"><link rel="prefetch" href="/notes/assets/js/89.c87c7c52.js"><link rel="prefetch" href="/notes/assets/js/9.6c59aa1b.js"><link rel="prefetch" href="/notes/assets/js/90.5b86a9fa.js"><link rel="prefetch" href="/notes/assets/js/91.67af2f50.js"><link rel="prefetch" href="/notes/assets/js/92.3d569806.js"><link rel="prefetch" href="/notes/assets/js/93.f09db3e6.js"><link rel="prefetch" href="/notes/assets/js/94.fa784778.js"><link rel="prefetch" href="/notes/assets/js/95.d5c98bd6.js"><link rel="prefetch" href="/notes/assets/js/96.09943d55.js"><link rel="prefetch" href="/notes/assets/js/97.a8c8ffe5.js"><link rel="prefetch" href="/notes/assets/js/98.c192dbb8.js"><link rel="prefetch" href="/notes/assets/js/99.ec4c4c65.js">
    <link rel="stylesheet" href="/notes/assets/css/0.styles.bb774922.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-dad8a512><div data-v-dad8a512><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-dad8a512 data-v-dad8a512><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-64685f0e data-v-dad8a512 data-v-dad8a512><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>邢走在云端</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>邢走在云端</span>
            
          <!---->
          2023
        </a></span></div></div> <div class="hide" data-v-dad8a512><header class="navbar" data-v-dad8a512><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/notes/" class="home-link router-link-active"><img src="/notes/img/favicon.png" alt="邢走在云端" class="logo"> <span class="site-name">邢走在云端</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/notes/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/categories/2019/" class="nav-link"><i class="iconfont undefined"></i>
  2019
</a></li><li class="dropdown-item"><!----> <a href="/notes/categories/2020/" class="nav-link"><i class="iconfont undefined"></i>
  2020
</a></li><li class="dropdown-item"><!----> <a href="/notes/categories/2021/" class="nav-link"><i class="iconfont undefined"></i>
  2021
</a></li><li class="dropdown-item"><!----> <a href="/notes/categories/2022/" class="nav-link"><i class="iconfont undefined"></i>
  2022
</a></li><li class="dropdown-item"><!----> <a href="/notes/categories/2023/" class="nav-link"><i class="iconfont undefined"></i>
  2023
</a></li></ul></div></div><div class="nav-item"><a href="/notes/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/notes/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><a href="http://notfound404.cn" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-date"></i>
  关于我
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="http://notfound404.cn/webpack5-docs/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-tag"></i>
  webpack5
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="http://notfound404.cn/hdesign/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  h-design
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/HunterXing" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-dad8a512></div> <aside class="sidebar" data-v-dad8a512><div class="personal-info-wrapper" data-v-ca798c94 data-v-dad8a512><img src="/notes/img/favicon.png" alt="author-avatar" class="personal-img" data-v-ca798c94> <h3 class="name" data-v-ca798c94>
    邢走在云端
  </h3> <div class="num" data-v-ca798c94><div data-v-ca798c94><h3 data-v-ca798c94>74</h3> <h6 data-v-ca798c94>Article</h6></div> <div data-v-ca798c94><h3 data-v-ca798c94>89</h3> <h6 data-v-ca798c94>Tag</h6></div></div> <hr data-v-ca798c94></div> <nav class="nav-links"><div class="nav-item"><a href="/notes/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/categories/2019/" class="nav-link"><i class="iconfont undefined"></i>
  2019
</a></li><li class="dropdown-item"><!----> <a href="/notes/categories/2020/" class="nav-link"><i class="iconfont undefined"></i>
  2020
</a></li><li class="dropdown-item"><!----> <a href="/notes/categories/2021/" class="nav-link"><i class="iconfont undefined"></i>
  2021
</a></li><li class="dropdown-item"><!----> <a href="/notes/categories/2022/" class="nav-link"><i class="iconfont undefined"></i>
  2022
</a></li><li class="dropdown-item"><!----> <a href="/notes/categories/2023/" class="nav-link"><i class="iconfont undefined"></i>
  2023
</a></li></ul></div></div><div class="nav-item"><a href="/notes/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/notes/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><a href="http://notfound404.cn" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-date"></i>
  关于我
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="http://notfound404.cn/webpack5-docs/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-tag"></i>
  webpack5
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="http://notfound404.cn/hdesign/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  h-design
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/HunterXing" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-64685f0e data-v-dad8a512><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>2023年再谈状态管理</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>邢走在云端</span>
            
          <!---->
          2023
        </a></span></div></div> <div data-v-dad8a512><main class="page"><div class="page-title" style="display:none;"><h1>2023年再谈状态管理</h1> <div data-v-3b7f5bdf><i class="iconfont reco-account" data-v-3b7f5bdf><span data-v-3b7f5bdf>邢走在云端</span></i> <i class="iconfont reco-date" data-v-3b7f5bdf><span data-v-3b7f5bdf>2023-07-30 11:01:49</span></i> <i class="iconfont reco-eye" data-v-3b7f5bdf><span id="/notes/notes/front/React/2023%E5%B9%B4react%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-3b7f5bdf><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="iconfont reco-tag tags" data-v-3b7f5bdf><span class="tag-item" data-v-3b7f5bdf>React</span></i></div></div> <div class="theme-reco-content content__default" style="display:none;"><h1 id="什么是状态管理"><a href="#什么是状态管理" class="header-anchor">#</a> 什么是状态管理？</h1> <h2 id="状态"><a href="#状态" class="header-anchor">#</a> 状态</h2> <p>状态是表示组件当前状况的 JS 对象。在 React 中，可以使用 useState 或者 this.state 维护组件内部状态，通过 props 传递给子组件使用。</p> <p>为了避免状态传递过程中出现混乱，React 引入了“单向数据流”的理念。主要思想是组件不会改变接收的数据，只会监听数据的变化，当数据发生变化时他们会使用接收到的新值，而不是修改已有的值。当组件的更新机制触发后，他们只是使用新值进行重新渲染。</p> <p>父子组件通信可以直接使用 props 和回调方式；深层次、远距离组件则要通过“状态提升”和 props 层层传递。</p> <h2 id="常见模式"><a href="#常见模式" class="header-anchor">#</a> 常见模式</h2> <p>React 状态管理的常见模式有：</p> <ul><li>状态提升：兄弟组件间是没法直接共享状态的，可以通过将状态提升到最近的祖先组件中，所有兄弟组件就可以通过 props 一级级传递获取状态；</li> <li>状态组合：某些状态可能只在应用程序的特定子树中需要。最好将状态存储在尽可能接近实际需要的位置，这有助于优化渲染行为；</li> <li>属性下钻：将父组件的状态以属性的形式一级级显示传递给嵌套子组件；</li> <li>Provider：React Context 通过 Provider 包裹组件，被包裹的所有嵌套子组件都可以不用通过属性下钻而是通过 context 直接获取状态。</li></ul> <p>层层传递的 value onChange 会对一个优质代码库带来的毁灭性影响，粗暴地把数据塞在 redux 中也并不能让一个应用得到很好的拓展性和可维护性。</p> <h2 id="要解决的问题"><a href="#要解决的问题" class="header-anchor">#</a> 要解决的问题</h2> <p>状态管理库要解决的问题：</p> <ol><li>从组件树的「任何地方」读取存储的状态</li> <li>写入存储状态的能力</li> <li>提供「优化渲染」的机制</li> <li>提供「优化内存使用」的机制</li> <li>与「并发模式的兼容性」</li> <li>数据的「持久化」</li> <li>「上下文丢失」问题</li> <li>「props失效」问题</li> <li>「孤儿」问题</li></ol> <h2 id="心智模型"><a href="#心智模型" class="header-anchor">#</a> 心智模型</h2> <p>状态更新有两种心智模型：</p> <ul><li>不可变状态模型</li> <li>可变状态模型</li> <li>主要好处是可以使用原生 JS 方法；</li> <li>基于 Proxy 的状态管理的一个缺点是状态不可预测，难以 debug。</li></ul> <p>因为 React 没有官方的状态管理方案，React 生态中状态管理库，百花齐放，演进出很多设计思想和心智模式。如何选择状态管理库就变得十分令人抓狂。</p> <h1 id="react-context"><a href="#react-context" class="header-anchor">#</a> React Context</h1> <p>在多级嵌套组件场景下，使用“属性下钻”方式进行组件通信是一件成本极高的事情。为了解决这个问题，React 官方提供 Context 用于避免一级级属性传递。</p> <p><img src="https://raw.githubusercontent.com/HunterXing/note-images/main/images/f820efcd983f4d3095b47727b083388c-20230730105300726.jpeg" alt="图片"></p> <h2 id="context-的问题"><a href="#context-的问题" class="header-anchor">#</a> Context 的问题</h2> <p>Context存在的问题也是老生常谈。在 react 里，context 是个反模式的东西，不同于 redux 等的细粒度响应式更新，context的值一旦变化，所有依赖该context的组件全部都会 force update，因为 context API 并不能细粒度地分析某个组件依赖了context 里的哪个属性，并且它可以穿透 React.memo 和 shouldComponentUpdate 的对比，把所有涉事组件强制刷新。</p> <p>React官方文档在 When to Use Context一节中写道：</p> <p>Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。</p> <p>综上，在系统中跟业务相关、会频繁变动的数据在共享时，应谨慎使用 context。</p> <p>如果决定使用context，可以在一些场景中，将多个子组件依赖的不同context属性提升到一个父组件中，由父组件订阅context并以prop的方式下发，这样可以使用子组件的memo、shouldComponentUpdate生效。</p> <p><img src="https://raw.githubusercontent.com/HunterXing/note-images/main/images/4eca3e92ab9444cc827029692113deda-20230730105310460.jpeg" alt="图片"></p> <p>此外，官方文档还提到了另外一个坑，使用的时候也应该注意。</p> <h2 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h2> <ul><li>作为React内置的hook，不需要引入第三方库；</li> <li>书写还算方便。</li></ul> <h2 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h2> <ul><li>Context 只能存储单一值，当数据量大起来时，你可能需要使用createContext创建大量context；</li> <li>直接使用的话，会有一定的性能问题：每一次对state的某个值变更，都会导致其他使用该state的组件re-render，即使没有使用该值。 你可以通过useMemo来解决这个问题，但是就需要一定的成本来定制一个通用的解决方案；</li> <li>无法处理异步请求。对于异步的逻辑，Context API并没有提供任何API，需要自己做封装；</li> <li>无法处理数据间的联动。Context API并没有提供API来生成派生状态，同样也需要自行去封装一些方法来实现。</li></ul> <h1 id="react-外部状态管理库"><a href="#react-外部状态管理库" class="header-anchor">#</a> React 外部状态管理库</h1> <h2 id="概览"><a href="#概览" class="header-anchor">#</a> 概览</h2> <p>React 的外部状态管理库一直以来是 React 生态中非常内卷的一个领域。目前比较常见的状态管理库有 Redux（包括基于 Redux 的 Dva、Icestore）、Mobx、Zustand、Recoil、Jotai、Valtio、Hox 等。</p> <p>从 npm trends 看各个状态管理库近一年的下载量趋势：</p> <p><img src="https://raw.githubusercontent.com/HunterXing/note-images/main/images/bc5ade52fc364074abce0ba866cc3a7b-20230730105318359.jpeg" alt="图片"></p> <p>我们可以看到 Redux 作为 React 状态管理的老大哥，下载量上依然遥遥领先其他库。Mobx 作为往年热度仅次于 Redux 的状态管理库，位置正逐步有被 zustand 超越的趋势。recoil/jotai/valtio 作为这两年热门的新兴库热度也在逐步上升。hox 则处于不温不火的尴尬地位。</p> <p>将以上状态管理库按心智模型、诞生时间、star 数，绘制气泡图。以 React v16.8 版本为分水岭，状态管理库可分为 Class 时代和 Hooks 时代。Class 时代中 Redux 和 Mobx 都是非常优秀的状态库。随着 Hooks 时代的到来，状态管理的心智模型也逐步发生着演变。整体呈现从中心化到去中心化，从单一状态到原子状态，从 Provider 到拥抱 Hooks 等演变趋势。</p> <p><img src="https://raw.githubusercontent.com/HunterXing/note-images/main/images/baeed480cfe9453bb99dfebd9b6b4ad3-20230730105329607.jpeg" alt="图片"></p> <p>下面，我们对上述状态管理库进行逐一对比介绍。</p> <h2 id="class-时代"><a href="#class-时代" class="header-anchor">#</a> Class 时代</h2> <h3 id="redux"><a href="#redux" class="header-anchor">#</a> Redux</h3> <p>Redux 的灵感来源于 Flux 架构和函数式编程原理，状态更新可预测、可跟踪，提倡使用「单一存储」。这通常会「导致将所有的东西存储在一个大的单体存储中」。将UI和远程实体状态之间的所有东西都放在一个地方管理，这变得非常难以管理。对性能造成了不小的压力。</p> <h4 id="单向数据流"><a href="#单向数据流" class="header-anchor">#</a> 单向数据流</h4> <p>他的工作流程大致如下：</p> <ul><li>用户在view层触发某个事件，通过dispatch发送了action和payload</li> <li>action和payload被传入reducer函数，返回一个新的state</li> <li>store拿到reducer返回的state并做更新，同时通知view层进行re-render</li></ul> <p><img src="https://raw.githubusercontent.com/HunterXing/note-images/main/images/43d5b0891a444573a90da572f239f8ef-20230730105357200.jpeg" alt="图片"></p> <p>由此可看出 Redux 遵循“单向数据流”和“不可变状态模型”的设计思想。这使得 Redux 的状态变化是可预测、可调式的。</p> <h4 id="三大原则"><a href="#三大原则" class="header-anchor">#</a> 三大原则</h4> <p>此外，Redux 还遵循三大原则：</p> <ul><li>单一数据源</li></ul> <p>整个应用的 全局 state被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store中。</p> <ul><li>state 是只读的</li></ul> <p>唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。</p> <ul><li>纯函数修改</li></ul> <p>通过 reducer 修改状态，reducer 是纯函数，它接收之前的 state 和 action，并返回新的 state。记住，一定要返回一个新的对象，而不是修改之前的 state。</p> <h4 id="如何处理异步"><a href="#如何处理异步" class="header-anchor">#</a> 如何处理异步</h4> <p>redux没有规定如何处理异步数据流，最原始的方式就是使用Action Creators，也就是在制造action之前进行各种的异步操作，你可以把要复用的操作抽离出来。</p> <p>当然这样并不优雅，在实际项目中我们通常使用类似redux-thunk、redux-saga这些中间件来支持处理异步。</p> <h4 id="如何处理数据间联动"><a href="#如何处理数据间联动" class="header-anchor">#</a> 如何处理数据间联动</h4> <p>react-redux的useSelector获取状态后，你可以编写一些逻辑来处理派生状态。如果派生状态需要复用，记得给抽离出来。</p> <h4 id="优点-2"><a href="#优点-2" class="header-anchor">#</a> 优点</h4> <ul><li>繁荣的社区，像不支持异步这种问题是由成熟的中间件可以解决的，你遇到的问题多多少少可以在社区找到答案;</li> <li>可扩展性高，中间件模式让你可以随心所欲的武装你的dispatch;</li> <li>单一数据源且是树形结构，这让redux支持回溯，在调试上也更方便;</li> <li>有成熟的开发调试工具 redux devtools。</li></ul> <h4 id="缺点-2"><a href="#缺点-2" class="header-anchor">#</a> 缺点</h4> <ul><li>陡峭的学习曲线。将副作用扔给中间件来处理，导致社区一堆中间件，学习成本陡然增加。比如处理异步请求的 Redux-saga、计算衍生状态的 reselect；</li> <li>大量的模版代码。使用 redux，开发者要编写大量和业务逻辑无关的模板代码，这给开发和后期维护都带来了额外的成本；</li> <li>大状态量情况下，性能较差。state 更新会影响所有组件。每个 action 都会调用所有 reducer；</li> <li>reducer 要返回新的对象，如果更新的值层级较深，更新成本也很高；</li> <li>更多的内存占用，由于采用单一数据源，所有状态存储在一个 state 中，当某些状态不再需要使用时，也不会被垃圾回收释放内存；</li></ul> <p>当然，redux 也在致力于解决上述缺点。比如，redux toolkit就旨在让开发者使用标准方式编写 redux 逻辑。主要解决 redux 的 3 个问题：</p> <ul><li>配置 redux store 过于麻烦；</li> <li>必须手动额外添加很多包才能正常使用 redux；</li> <li>redux 需要太多模板代码。</li></ul> <p>不过，即使有 redux toolkit 的加持，redux 的学习成本依旧不低。</p> <h3 id="dva"><a href="#dva" class="header-anchor">#</a> Dva</h3> <p>dva 首先是一个基于 redux和 redux-saga的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router和 fetch，所以也可以理解为一个轻量级的应用框架。</p> <p>Dva 的特点：</p> <ul><li>易学易用，仅有 6 个 api，对 redux 用户尤其友好，配合 umi 使用后更是降低为 0 API</li> <li>elm 概念，通过 reducers, effects 和 subscriptions 组织 model</li> <li>插件机制，比如 dva-loading可以自动处理 loading 状态，不用一遍遍地写 showLoading 和 hideLoading</li> <li>支持 HMR，基于 babel-plugin-dva-hmr实现 components、routes 和 models 的 HMR</li></ul> <p>Dva 大幅降低了 Redux 的上手成本，过去也在社区拥有了拥趸，github star 数 16.1k。不过，从 2019.11 开始就没有新的版本发布，看起来已经处于不维护状态。</p> <h3 id="icestore"><a href="#icestore" class="header-anchor">#</a> icestore</h3> <p>icestore 是 IceJs内置状态管理库。icestore 是面向 React 应用的、简单友好的状态管理方案。</p> <p>它包含以下核心特征：</p> <ul><li>简单、熟悉的 API：不需要额外的学习成本，只需要了解 React Hooks，对 Redux 用户友好。</li> <li>集成异步处理：记录异步操作时的执行状态，简化视图中对于等待或错误的处理逻辑。</li> <li>支持组件 Class 写法：友好的兼容策略可以让老项目享受轻量状态管理的乐趣。</li> <li>良好的 TypeScript 支持：提供完整的 TypeScript 类型定义，在 VS Code 中能获得完整的类型检查和推断。</li></ul> <p>icestore 的灵感来自于 rematch和 constate。整体实现和 rematch 基本一致。rematch 是一个没有模板代码的 redux 最佳实践。icestore 整体配置简单，解决了 redux 学习成本高、大量模板代码等问题，同时又很好的支持了异步处理、TypeScript 和 SSR。</p> <p>IceJS 自己给出的能力对照表：</p> <ul><li>O: 支持</li> <li>X: 不支持</li> <li>+: 需要额外地进行能力扩展</li></ul> <table><thead><tr><th>功能/库</th> <th>redux</th> <th>constate</th> <th>zustand</th> <th>react-tracked</th> <th>icestore</th></tr></thead> <tbody><tr><td>框架</td> <td>Any</td> <td>React</td> <td>React</td> <td>React</td> <td>React</td></tr> <tr><td>简单性</td> <td>★★</td> <td>★★★★</td> <td>★★★</td> <td>★★★</td> <td>★★★★</td></tr> <tr><td>更少的模板代码</td> <td>★</td> <td>★★</td> <td>★★★</td> <td>★★★</td> <td>★★★★</td></tr> <tr><td>可配置性</td> <td>★★</td> <td>★★★</td> <td>★★★</td> <td>★★★</td> <td>★★★★★</td></tr> <tr><td>共享状态</td> <td>O</td> <td>O</td> <td>O</td> <td>O</td> <td>O</td></tr> <tr><td>复用状态</td> <td>O</td> <td>O</td> <td>O</td> <td>O</td> <td>O</td></tr> <tr><td>状态联动</td> <td>+</td> <td>+</td> <td>+</td> <td>+</td> <td>O</td></tr> <tr><td>Class 组件支持</td> <td>O</td> <td>+</td> <td>+</td> <td>+</td> <td>O</td></tr> <tr><td>Function 组件支持</td> <td>O</td> <td>O</td> <td>O</td> <td>O</td> <td>O</td></tr> <tr><td>异步更新的状态</td> <td>+</td> <td>X</td> <td>X</td> <td>X</td> <td>O</td></tr> <tr><td>SSR</td> <td>O</td> <td>O</td> <td>X</td> <td>O</td> <td>O</td></tr> <tr><td>持久化</td> <td>+</td> <td>X</td> <td>X</td> <td>X</td> <td>+</td></tr> <tr><td>懒加载模型</td> <td>+</td> <td>+</td> <td>+</td> <td>+</td> <td>O</td></tr> <tr><td>中心化</td> <td>+</td> <td>X</td> <td>X</td> <td>X</td> <td>O</td></tr> <tr><td>中间件或插件机制</td> <td>O</td> <td>X</td> <td>O</td> <td>X</td> <td>O</td></tr> <tr><td>开发者工具</td> <td>O</td> <td>X</td> <td>O</td> <td>X</td> <td>O</td></tr></tbody></table> <h2 id="mobx"><a href="#mobx" class="header-anchor">#</a> Mobx</h2> <h3 id="设计思想"><a href="#设计思想" class="header-anchor">#</a> 设计思想</h3> <p>MobX 的主要思想是用「函数响应式编程」和「可变状态模型」使得状态管理变得简单和可扩展。</p> <p>MobX背后的哲学很简单:</p> <p>任何源自应用状态的东西都应该自动地获得。其中包括UI、数据序列化、服务器通讯，等等。</p> <p>React 和 MobX 是一对强力组合。React 通过提供机制把应用状态转换为可渲染组件树并对其进行渲染。而MobX提供机制来存储和更新应用状态供 React 使用。</p> <p>对于应用开发中的常见问题，React 和 MobX 都提供了最优和独特的解决方案。React 提供了优化UI渲染的机制， 这种机制就是通过使用虚拟DOM来减少昂贵的DOM变化的数量。MobX 提供了优化应用状态与 React 组件同步的机制，这种机制就是使用响应式虚拟依赖状态图表，它只有在真正需要的时候才更新并且永远保持是最新的。</p> <h3 id="心智模型-2"><a href="#心智模型-2" class="header-anchor">#</a> 心智模型</h3> <p>Mobx的心智模型和react很像，它区分了应用程序的三个概念：</p> <ul><li>State(状态)</li> <li>Actions(动作)</li> <li>Derivations(派生)</li></ul> <p>首先创建可观察的状态（Observable State），通过Action更新State，然后自动更新所有的派生（Derivations）。派生包括Computed value（类似useMemo或useSelector）、副作用函数(类似useEffect)和UI（render）。</p> <p><img src="https://raw.githubusercontent.com/HunterXing/note-images/main/images/338b3e75c087489183aa804db04df807-20230730105431791.jpeg" alt="图片"></p> <p>Mobx虽然心智模型像 react，但是实现却是完完全全的 vue：mutable + proxy（为了兼容性，proxy实际上使用Object.defineProperty实现）。</p> <p>使用反react的数据流模式，注定会有成本：</p> <ul><li>Mobx的响应式脱离了react自身的生命周期，就不得不显式声明其派生的作用时机和范围。比如副作用触发需要在useEffect里再跑一个autorun/reaction，要给DOM render包一层useObserver/Observer，都加大了开发成本。</li> <li>Mobx会在组件挂载时收集依赖，和state建立联系，这个方式在即将到来的react 18的并发模式（Concurrent Mode）中，可能无法平滑地迁移。为此，react专门开发了create-subscription方法用于在组件中订阅外部源，但是实际的应用效果还未可知。</li></ul> <p>尤大本人也盖过章：React + MobX 本质上就是一个更繁琐的Vue。</p> <h3 id="mobx-vs-redux"><a href="#mobx-vs-redux" class="header-anchor">#</a> Mobx vs Redux</h3> <p>Mobx和Redux的对比，实际上可以归结为 面向对象 vs 函数式和 Mutable vs Immutable。</p> <ul><li>相比于redux的广播遍历dispatch，然后遍历判断引用来决定组件是否更新，mobx基于proxy可以精确收集依赖、局部更新组件（类似vue），理论上会有更好的性能，但redux认为这可能不是一个问题（Won't calling “all my reducers” for each action be slow?）</li> <li>Mobx因为数据只有一份引用，没有回溯能力，不像redux每次更新都相当于打了一个快照，调试时搭配redux-logger这样的中间件，可以很直观地看到数据流变化历史。</li> <li>Mobx的学习成本更低，没有全家桶。</li> <li>Mobx在更新state中深层嵌套属性时更方便，直接赋值就好了，redux则需要更新所有途经层级的引用（当然搭配immer也不麻烦）。</li></ul> <h2 id="优点-3"><a href="#优点-3" class="header-anchor">#</a> 优点</h2> <ul><li>简单易用，没有模板代码；</li> <li>精准更新，性能更好；</li></ul> <h2 id="缺点-3"><a href="#缺点-3" class="header-anchor">#</a> 缺点</h2> <ul><li>难以调试。由于采用可变状态模型，状态不可预测和追溯，难以 debug；</li> <li>太过灵活，更容易导致 bug；</li> <li>响应式是基于 Proxy 实现的，希望传递的是一个数组，拿到的却是一个 Proxy。排查问题时有点痛苦。</li></ul> <h1 id="hooks-时代"><a href="#hooks-时代" class="header-anchor">#</a> Hooks 时代</h1> <p>Hooks 是 React 16.8 新增的特性，使得我们可以在函数组件中使用 state 以及其他 React 特性。</p> <p>Hooks 的引入主要是为了解决 React Class 组件的以下问题：</p> <ul><li>在组件之间复用状态逻辑很难</li></ul> <p>Class 组件会将视图和状态逻辑糅杂在一起，如果想复用组件中的状态逻辑，需要使用 render props 和高阶组件，但是这类方案需要重新组织组件结构，会形成组件的嵌套地狱，代码逻辑也会变得难以理解。</p> <ul><li>复杂组件的理解成本很高</li></ul> <p>Class 组件的状态逻辑会充斥在各个生命周期中，完全不相关的代码出现在同一个生命周期函数中，逻辑难以理解，容易引发 bug，且在多数情况下，很难将组件拆分成更小的粒度。</p> <p>Hooks 是一种开发理念和组织理念的革新，有 3 个特性：</p> <ul><li>primitive。元数据化，将混沌的 state 打散为一个个元数据；</li> <li>decentralization。去中心化，Class 时代的理念是“顶层下发”，Hooks 带来了强烈的“组件自治”理念；</li> <li>algebraic effects。代数效应，剥离组件中的副作用，让开发者更专注业务逻辑。</li></ul> <p>代数效应是函数式编程中的一个概念，用于将副作用从函数调用中分离。</p> <h2 id="自下而上模式的崛起"><a href="#自下而上模式的崛起" class="header-anchor">#</a> 自下而上模式的崛起</h2> <p>我们可以看到以前的状态管理解决方案，如Redux，设计理念是状态 「自上而下」流动。它「倾向于在组件树的顶端吸走所有的状态」。状态被维护在组件树的高处，下面的组件通过选择器拉取他们需要的状态。</p> <p>在新的组件构建理念中，一种「自下而上」的观点对构建具有组合模式的应用具有很好的指导作用。</p> <p>而hook就是这种理念的践行者，即把可组合的部件放在一起形成一个更大的整体。</p> <p>通过 hook，我们可以从具有巨大全局存储的「单体状态管理」转变为向自下而上的 「微状态管理」，通过hook消费更小的状态片。</p> <p>像接下来要介绍的 Recoil 和 Jotai 这样的流行库以其 「原子状态」的概念体现了这种自下而上的理念。「原子是一个最小但完整的状态单位」。它们是小块的状态，可以连接在一起形成新的衍生状态。最终形成了一个应用状态图。</p> <p>这个模型允许你自下而上地建立起「状态图」。并通过仅使图中已更新的原子失效来优化渲染。</p> <p>这与拥有一个大的单体状态球形成鲜明对比，你可以「订阅并试图避免不必要的渲染」。</p> <p>接下来我们要介绍 5 个 Hooks 时代的状态库，分别是 recoil、zustand、jotai、valtio、hox。比较有趣的是其中 3 个都是 Daishi Kato开发的，采用了不同的设计思想，但是都在短期内取得不错的社区热度，这 3 个库分别是 zustand、jotai、valtio，这三个词其实是“状态”在 3 种语言中的不同发音。</p> <p>zustand 🇩🇪 德语 &quot;状态&quot;，jotai 🇯🇵 日语 &quot;状态&quot;、valtio 🇫🇮 芬兰语 &quot;状态&quot;。</p> <h2 id="recoil"><a href="#recoil" class="header-anchor">#</a> Recoil</h2> <h3 id="简介"><a href="#简介" class="header-anchor">#</a> 简介</h3> <p>Recoil 是在React Europe 2020 Conference上 facebook 官方推出的专为 react 打造的状态管理库，动机是解决react 状态共享模式的局限性：</p> <ul><li>以往只能将state提升到公共祖先来实现状态共享，并且一旦这么做了，基本就无法将组件树的顶层（state 必须存在的地方）与叶子组件 (使用 state 的地方) 进行代码分割</li> <li>Context 只能存储单一值，无法存储多个各自拥有消费者的值的集合</li></ul> <h3 id="设计思想-2"><a href="#设计思想-2" class="header-anchor">#</a> 设计思想</h3> <p>Recoil的状态集是一个有向图 (directed graph)，正交且天然连结于React组件树。状态的变化从该图的顶点（atom）开始，流经纯函数 (selector) 再传入组件。</p> <p><img src="https://raw.githubusercontent.com/HunterXing/note-images/main/images/577484c75e134cb1be75d3e01d846f05-20230730105541556.jpeg" alt="图片"></p> <p>Recoil 定义了一个有向图 (directed graph)，正交同时又天然连结于你的 React 树上。状态的变化从该图的顶点（我们称之为 atom）开始，流经纯函数 (我们称之为 selector) 再传入组件。基于这样的实现：</p> <ul><li>我们可以定义无需模板代码的 API，共享的状态拥有与 React 本地 state 一样简单的 get/set 接口 (当然如果需要，也可以使用 reducer 等进行封装)；</li> <li>我们有了与 Concurrent 模式及其他 React 新特性兼容的可能性；</li> <li>状态的定义是渐进式和分布式的，这使代码分割成为可能；</li> <li>无需修改对应的组件，就能将它们本地的 state 用派生数据替换；</li> <li>无需修改对应的组件，就能将派生数据在同步与异步间切换；</li> <li>我们能将导航视为头等概念，甚至可以将状态的转变编码进链接中；</li> <li>可以很轻松地以可回溯的方式持久化整个应用的状态，持久化的状态不会因为应用的改变而丢失。</li></ul> <p>正交：相互独立，相互间不可替代，并且可以组合起来实现其它功能</p> <p>Recoil每一次状态变更都会生成一个不可变的快照，利用这个特性，可以快速实现应用导航相关的功能，例如状态回溯、跳转等。</p> <h3 id="核心方法"><a href="#核心方法" class="header-anchor">#</a> 核心方法</h3> <p>Recoil中定义状态的两个核心方法：</p> <ul><li>atom: 定义原子状态，即组件的某个状态最小集，</li> <li>selector: 定义派生状态，其实就是computed value</li></ul> <p>消费状态的方法有 useRecoilState、useRecoilValue、useSetRecoilState 等，用法和 react 的 useState 类似，几乎没有上手成本。另外值得注意的是，recoil目前只支持FC的hook用法，Class组件想用的话可以通过HOC的方式获取状态并注入组件。</p> <h3 id="优点-4"><a href="#优点-4" class="header-anchor">#</a> 优点</h3> <ul><li>状态原子化（atom），自由组合和订阅；并且状态定义是渐进式和分布式的，使代码分割成为可能；</li> <li>没有模板代码，天然是 hook 模式，让 react 尽量保持原来的样子；</li> <li>兼容并发模式（Concurrent Mode）；</li> <li>提供对状态流的快照（snapshot）支持，可以轻松回溯应用状态，甚至将snopshot编码放进url，让任何人打开应用都能进入到同样的状态；</li></ul> <h3 id="能力对照表"><a href="#能力对照表" class="header-anchor">#</a> 能力对照表</h3> <table><thead><tr><th>方案</th> <th>学习成本</th> <th>编码成本</th> <th>TS友好</th> <th>SSR</th> <th>Code Split</th> <th>并发模式兼容</th> <th>可调试性</th> <th>生态繁荣</th></tr></thead> <tbody><tr><td>Redux</td> <td>高</td> <td>高</td> <td>一般</td> <td>支持</td> <td>不支持</td> <td>支持</td> <td>好</td> <td>高</td></tr> <tr><td>Mobx</td> <td>中</td> <td>中</td> <td>好</td> <td>支持</td> <td>支持</td> <td>未知</td> <td>差</td> <td>中</td></tr> <tr><td>Recoil</td> <td>低</td> <td>低</td> <td>好</td> <td>实践较少</td> <td>支持</td> <td>支持</td> <td>好</td> <td>低</td></tr></tbody></table> <h2 id="zustand"><a href="#zustand" class="header-anchor">#</a> Zustand</h2> <h3 id="简介-2"><a href="#简介-2" class="header-anchor">#</a> 简介</h3> <p>zustand 是一个轻量级状态管理库，和 redux 一样都是基于不可变状态模型和单向数据流的，状态对象 state 不可被修改，只能被替换。渲染优化要手动通过 selectors 进行。</p> <h3 id="zustand-vs-redux"><a href="#zustand-vs-redux" class="header-anchor">#</a> Zustand vs Redux</h3> <ul><li>zustand 和 redux 是非常像的，都基于不可变状态模型，都基于单向数据流。</li> <li>不过，redux 需要应用被 Context Provider 包裹，zustand 则不需要。</li> <li>二者更新数据的方式不同，redux 基于 reducers，更新状态的 reducers 是严格的方法，这就使得状态更加可预测。zustand 不使用 reducers 而是通过更灵活的方法来更新状态。</li></ul> <h3 id="特点"><a href="#特点" class="header-anchor">#</a> 特点</h3> <p>zustand 的特点：</p> <ul><li>轻量级；</li> <li>中心化，单一 store；</li> <li>不可变状态模型；</li> <li>不固执。很少限制，非常开放。</li></ul> <h2 id="jotai"><a href="#jotai" class="header-anchor">#</a> Jotai</h2> <h3 id="简介-3"><a href="#简介-3" class="header-anchor">#</a> 简介</h3> <p>jotai 是一个小型全局状态管理库，它模仿了 useState、useReducer。jotai 有个叫做 atom 的概念，用于表示小的状态片段。和 zustand 不同的是，他是一个组件级别的状态管理库。和 zustand 相同的是同样都基于不可变状态模型。</p> <p>jotai 是 Context 和订阅机制的结合，是面向 React 的一种全局状态管理库。如果你的需求是一个没有额外重复渲染的 Context，那 jotai 是个不错的选择。</p> <h3 id="特点-2"><a href="#特点-2" class="header-anchor">#</a> 特点</h3> <p>jotai 有两个特点：</p> <ul><li>语法简单</li> <li>jotai 的状态不是全局状态</li></ul> <p>atom 可以在 React 组件的生命周期里创建和销毁。这通过多个 Context 是无法实现的，因为使用 Context 增加一个新的 state 意味着增加一个新的 Provider 组件，如果新增一个组件，它所有的子组件都会被重新挂载，会失去所有状态。</p> <ul><li>衍生 atom</li></ul> <p>atom 可以像积木一样被组合，生成新的 atom，从而实现复杂逻辑。</p> <p>jotai 通过 atom 之间的依赖来实现自动渲染优化。</p> <p>推荐场景：组件为中心的应用。</p> <h3 id="recoil-vs-jotai"><a href="#recoil-vs-jotai" class="header-anchor">#</a> Recoil vs Jotai</h3> <p>jotai 深受 recoil 启发，设计理念基本相同。但有以下不同：</p> <ul><li>最大的不同是是否需要键字符串，开发 jotai 的一大动力就是要省略键字符串。因为键属性必须是唯一的，键命名是一项艰巨的任务；</li> <li>另一个不同是 jotai 不需要使用 Provider 包裹组件，这对开发者来说可以大幅降低开发成本和心理负担。</li></ul> <h3 id="zustand-vs-jotai"><a href="#zustand-vs-jotai" class="header-anchor">#</a> Zustand vs Jotai</h3> <p>Zustand 和 Jotai 之间有两个主要不同：</p> <ul><li>Zustand 是单一 store，Jotai 由原子 atom 组合而成；</li> <li>Zustand 的 store 存储在 React 外部，Jotai 的 store 存储在 React 内部。</li></ul> <h2 id="valtio"><a href="#valtio" class="header-anchor">#</a> Valtio</h2> <h3 id="简介-4"><a href="#简介-4" class="header-anchor">#</a> 简介</h3> <p>基于可变状态模型，利用 Proxy 获取一个和 React 集成在一起的不可变快照。</p> <p>利用 Proxy 自动进行重新渲染优化，这个过程使用了状态使用跟踪技术。通过状态使用跟踪，可以检测到状态的哪部分被使用，让组件实现按使用重新渲染。同时，开发者也可以编写更少的代码。</p> <h3 id="valtio-vs-zustand"><a href="#valtio-vs-zustand" class="header-anchor">#</a> Valtio vs Zustand</h3> <p>zustand 基于不可变状态模型，valtio 基于可变状态模型。</p> <p>valtio 通过属性访问自动进行渲染优化，zustand 推荐使用 selectors 手动进行渲染优化。</p> <h3 id="valtio-vs-mobx"><a href="#valtio-vs-mobx" class="header-anchor">#</a> Valtio vs Mobx</h3> <p>渲染优化上，valtio 使用 hook，mobx 使用高阶组件。</p> <h2 id="hox"><a href="#hox" class="header-anchor">#</a> Hox</h2> <h3 id="从状态管理到状态共享"><a href="#从状态管理到状态共享" class="header-anchor">#</a> 从状态管理到状态共享</h3> <p>redux、zustand、recoil 这些状态管理库，它们虽然在一定程度上也可以帮我们解决数据共享的问题，但它们最本质的能力还是对数据的操作。它们被称做也确实应该被称做&quot;状态管理&quot;工具。</p> <p>而 Hox 想解决的问题，不是如何组织和操作数据，不是数据流的分层、异步、细粒度，我们希望 Hox 只聚焦于一个痛点：在多个组件间共享状态。</p> <p>如果你也意识到了，层层传递的 value onChange 会对一个优质代码库带来的毁灭性影响，粗暴地把数据塞在 redux 中也并不能让一个应用得到很好的拓展性和可维护性，那么 Hox 或许会是一个适合你的&quot;状态共享&quot;方案，它简单、轻量、可靠，适合无论大小的几乎所有项目。</p> <h3 id="优势"><a href="#优势" class="header-anchor">#</a> 优势</h3> <ul><li>直接复用已有的 React 知识，几乎没有学习成本，你怎么写 React 组件，就可以怎么写 Store</li> <li>为灵活重构而设计，在 Store 和组件中使用同一套 DSL 可以让你几乎 0 成本的将组件的局部状态转化为一个组件间共享的状态</li> <li>同时支持局部状态和全局状态，在灵活和简单之间做到了很好的平衡</li> <li>优秀的性能和 TypeScript 支持</li></ul> <h1 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h1> <p>简单场景使用原生的useState、useReducer、useContext就能满足；还可以用 Hox这样小而美的库将hook的状态直接拓展成持久化状态，几乎没有额外的心智负担。</p> <p>复杂场景的应用，redux、mobx都是经受过千锤百炼的库，社区生态也很完备。</p> <p>Redux高度模板化、分层化，职责划分清晰，塑造了其状态在可回溯、可维护性方面的优势；搭配thunk、saga这些中间件几乎是无所不能。</p> <p>Mobx的优势是写法简单和高性能，但状态的可维护性不如redux，在并发模式中的兼容性也有待观察。</p> <p>随着hook和有官方背景的recoil的出现，状态管理似乎在朝原子化、组件化的方向发展，这也符合react的组件化哲学。Redux的暴力遍历和分发或许已经是逆潮流的解法。</p> <p>没有最好的状态管理库，只有最合适的状态管理库。</p> <p>详细状态库能力对照表：</p> <table><thead><tr><th></th> <th>Class 时代</th> <th>Hooks 时代</th> <th></th> <th></th> <th></th> <th></th> <th></th> <th></th> <th></th></tr></thead> <tbody><tr><td></td> <td>传统流 派</td> <td>响应式 流派</td> <td>原子状 态流派</td> <td>传统流 派</td> <td>响应式 流派</td> <td>原子状 态流派</td> <td></td> <td></td> <td></td></tr> <tr><td></td> <td>redux</td> <td>dvajs</td> <td>icestor e（ice 内置）</td> <td>mobx</td> <td>recoil</td> <td>zustand</td> <td>Valtio</td> <td>Jotai</td> <td>hox</td></tr> <tr><td>STAR数</td> <td>59k</td> <td>16.1k</td> <td>387</td> <td>26k</td> <td>18.1k</td> <td>24.5k</td> <td>5.9k</td> <td>11.3k</td> <td>1.3k</td></tr> <tr><td>诞生时间</td> <td>2011</td> <td>2016.12</td> <td>2019.3</td> <td>2015.3</td> <td>2019</td> <td>2018</td> <td>2020.11</td> <td>2020.3</td> <td>2019.1</td></tr> <tr><td>特性</td> <td>全局一 棵状态 树，利 用cont ext，通 过actio n 触发 变动，r educer 纯函数 修改sto re，最 后导致 prop s 变 动，进 而组件 重新渲 染</td> <td>深度整 合 redu x、red ux-sag a，便 于 redu x 用户 快速切 换</td> <td>类 dvaj s，创造 icestor e 的灵 感来自 于 rem atch 和 constat e。</td> <td>基于ES6 prox y ，使 用观察 者/可观 察模式 的，当 你修改 一个值 时，任 何使用 该值的 组件都 会自动 重新渲 染。</td> <td>原子化 管理状 态，进 行精确 渲染。 使用 Re coil 会 为你创 建一个 数据流 向图， 从 atom （共享状 态）到 selecto r（纯函 数），再 流向 Reac t 组件。 Atom 是组件 可以订 阅的 sta te 单位。 selecto r 可以同 步或异 步改变 此 state。</td> <td>基于观 察者/可 观察模 式，内 部对通 过 stat e 绑定 的组件， 添加到 了订阅 者队列， store中 的属性 相当于 一个被 观察者， 当属性 状态变 更后， 通知所 有订阅 了该数 属性的 组件进 行更新</td> <td>利用 P roxy 自 动进行 重新渲 染优化， 这个过 程使用 了状态 使用跟 踪技术。 通过状 态使用 跟踪， 可以检 测到状 态的哪 部分被 使用， 让组件 实现按 使用重 新渲染。 同时， 开发者 也可以 编写更 少的代 码。</td> <td>jotai 是一个 小型全 局状态 管理库， 它模仿 了useS tate、u seRedu cer。jot ai 有个 叫做 ato m 的概念， 用于表 示小的 状态片 段。和 zustan d 不同 的是，他 是一个组 件级别 的状态 管理库。 和 zustan d 相同的 是同样 都基于 不可变 状态模 型。</td> <td>类似于 自定义 hook， 利用u seSta te 能 力，st ate状态 变化触 发组件 重新渲 染</td></tr> <tr><td>学习成本</td> <td>很高</td> <td>低</td> <td>低</td> <td>中</td> <td>低</td> <td>低</td> <td>低</td> <td>低</td> <td>低</td></tr> <tr><td>使用成本</td> <td>很高， 模板代 码多</td> <td>低，仅 有6个A PI</td> <td>低</td> <td>中</td> <td>低</td> <td>低</td> <td>低</td> <td>低</td> <td>低</td></tr> <tr><td>Typescript友好</td> <td>友好</td> <td>不友 好，没 有清晰 的依赖 关系， 类型支 持很差</td> <td>友好</td> <td>友好</td> <td>友好</td> <td>友好</td> <td>友好</td> <td>友好</td> <td>友好</td></tr> <tr><td>状态拆分</td> <td>react/t oolki t creat eSlice</td> <td>支持</td> <td>支持</td> <td>支持</td> <td>支持</td> <td>支持</td> <td>支持</td> <td>支持</td> <td>支持</td></tr> <tr><td>性能</td> <td>中等</td> <td>中等</td> <td>中等</td> <td>好</td> <td>好</td> <td>中等</td> <td>好</td> <td>好</td> <td>好</td></tr> <tr><td>异步支持</td> <td>不友好</td> <td>友好</td> <td>友好</td> <td>友好</td> <td>友好</td> <td>友好</td> <td>友好</td> <td>友好</td> <td>友好</td></tr> <tr><td>React concurrent 模式支持</td> <td>支持</td> <td></td> <td>支持</td> <td>支持</td> <td>支持</td> <td>支持</td> <td>支持</td> <td>支持</td> <td></td></tr> <tr><td>易于调试</td> <td>是</td> <td>是</td> <td>是</td> <td>否</td> <td>是</td> <td>是</td> <td>否</td> <td>是</td> <td></td></tr> <tr><td>devtools</td> <td>有</td> <td>有</td> <td>有</td> <td>无</td> <td>无</td> <td>有</td> <td>无</td> <td>无</td> <td>无</td></tr> <tr><td>SSR</td> <td>支持</td> <td></td> <td>支持</td> <td>支持</td> <td>支持， 但可能 不健全</td> <td>支持， 但可能 不健全</td> <td>支持， 但可能 不健全</td> <td>支持， 但可能 不健全</td> <td>不支持</td></tr></tbody></table> <h1 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h1> <ul><li>Do React Hooks Replace Redux?</li> <li>React 状态管理工具：我是这样选择的</li> <li>You Might Not Need Redux</li> <li>各流派 React 状态管理对比和原理实现</li> <li>盘点React常见的状态管理方式</li> <li>2022 年，我们再来谈谈 React 状态管理</li> <li>DvaJS</li> <li>支付宝前端应用架构的发展和选择</li> <li>HoxJS</li> <li>Redux vs Zustand</li> <li>React 状态管理新浪潮</li> <li>React-全局状态管理的群魔乱舞</li> <li>各流派 React 状态管理对比和原理实现 - mdnice 墨滴</li> <li>自述 · Redux</li> <li>Recoil - Facebook 官方 React 状态管理器</li> <li>[译] React 状态管理的前世，今生和未来 - 开发者头条</li> <li>2021年的React状态管理 - 掘金</li> <li>状态管理方案发展概览</li> <li>State Management: Overview | React Common Tools and Practices</li> <li>Blogged Answers: Why React Context is Not a “State Management” Tool (and Why It Doesn’t Replace Redux)</li> <li>zustand vs redux</li> <li>hox - 下一代 React 状态管理器</li> <li>MobX vs Redux: Evaluating Two Popular Libraries For State Management | SPEC INDIA</li> <li>React 状态管理的新浪潮</li> <li>Redux 的性能问题</li> <li>mobx vs redux</li> <li>zustand vs jotai vs valtio</li></ul></div> <footer class="page-edit" style="display:none;"><!----> <!----></footer> <!----> <!----> <!----></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/notes/assets/js/app.660493da.js" defer></script><script src="/notes/assets/js/3.db1e4918.js" defer></script><script src="/notes/assets/js/1.f8ceeabf.js" defer></script><script src="/notes/assets/js/82.f409e717.js" defer></script>
  </body>
</html>
