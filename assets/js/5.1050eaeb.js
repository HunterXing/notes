(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{525:function(e,t,r){e.exports=r.p+"assets/img/49001027-6a8fd680-f196-11e8-9f19-acc0c9f21284.e86888fe.png"},526:function(e,t,r){e.exports=r.p+"assets/img/49001571-fce4aa00-f197-11e8-84cc-9571508f77f4-20220122213703140.a5ad533e.png"},527:function(e,t,r){e.exports=r.p+"assets/img/49001922-0e7a8180-f199-11e8-9817-9e5d509f4901.423c8023.png"},528:function(e,t,r){e.exports=r.p+"assets/img/49002250-0c64f280-f19a-11e8-8dc2-2e87e4d200fe.16726d15.png"},529:function(e,t,r){e.exports=r.p+"assets/img/49002755-66b28300-f19b-11e8-907b-013a565d944b.830e4a01.png"},530:function(e,t,r){e.exports=r.p+"assets/img/49003444-e260ff80-f19c-11e8-997a-38a5a4ebeb7c-20220122213812490.dfeb834e.png"},531:function(e,t,r){e.exports=r.p+"assets/img/49004115-89926680-f19e-11e8-95b7-aad5e7fdf83b.3c939310.png"},532:function(e,t,r){e.exports=r.p+"assets/img/49004764-fc501180-f19f-11e8-8242-7140fabbf5f2.529b86ed.png"},533:function(e,t,r){e.exports=r.p+"assets/img/49005590-0e32b400-f1a2-11e8-8d94-a501140a187f.8e23c78f.png"},534:function(e,t,r){e.exports=r.p+"assets/img/49005704-5225b900-f1a2-11e8-8083-3c73464d5a78.687ad702.png"},535:function(e,t,r){e.exports=r.p+"assets/img/49010480-4fc95c00-f1ae-11e8-8aa6-097d16c1c2db.ae447c28.png"},536:function(e,t,r){e.exports=r.p+"assets/img/49010863-7936b780-f1af-11e8-88f8-1ab083f3eafe.b11994d4.png"},537:function(e,t,r){e.exports=r.p+"assets/img/49011369-25c56900-f1b1-11e8-8ce8-69c5218ad0d1.31f0a09d.png"},538:function(e,t,r){e.exports=r.p+"assets/img/49011621-daf82100-f1b1-11e8-93d1-8da5567c8279.e0ec4c0f.png"},539:function(e,t,r){e.exports=r.p+"assets/img/49011944-daac5580-f1b2-11e8-89b4-edff1b2f7a1e.02c0a915.png"},540:function(e,t,r){e.exports=r.p+"assets/img/49012281-e8aea600-f1b3-11e8-9c30-84b2dd3b5d8b.cc5f3752.png"},541:function(e,t,r){e.exports=r.p+"assets/img/49012449-6ecaec80-f1b4-11e8-8435-7e4e9776b049.2c40bc13.png"},542:function(e,t,r){e.exports=r.p+"assets/img/49012604-dc771880-f1b4-11e8-855a-1bbb56a676b2.32514f5a.png"},543:function(e,t,r){e.exports=r.p+"assets/img/49012781-6f17b780-f1b5-11e8-832c-a6fb001c7cea.ffd9ec7c.png"},544:function(e,t,r){e.exports=r.p+"assets/img/49012911-eb11ff80-f1b5-11e8-9787-e89074659389.e995cde5.png"},545:function(e,t,r){e.exports=r.p+"assets/img/49023266-cfb4ed80-f1d1-11e8-9834-5cb94708ce8c.75854dc8.png"},546:function(e,t,r){e.exports=r.p+"assets/img/49024698-0f310900-f1d5-11e8-9ecf-cbc478cc1518-20220122214035155.6779399b.png"},547:function(e,t,r){e.exports=r.p+"assets/img/49027118-6f767980-f1da-11e8-900b-128be1575e12.e88b6bda.png"},731:function(e,t,r){"use strict";r.r(t);var a=r(4),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("blockquote",[a("p",[e._v("转载自 CodeLittlePrince 的github issue "),a("a",{attrs:{href:"https://github.com/CodeLittlePrince/blog/issues/19",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/CodeLittlePrince/blog/issues/19"),a("OutboundLink")],1)])]),e._v(" "),a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),a("p",[e._v("首先，先说明下该文章是译文，原文出自"),a("a",{attrs:{href:"https://itnext.io/ast-for-javascript-developers-3e79aeb08343",target:"_blank",rel:"noopener noreferrer"}},[e._v("《AST for JavaScript developers》"),a("OutboundLink")],1),e._v("。很少花时间特地翻译一篇文章，咬文嚼字是件很累的事情，实在是这篇写的太棒了，所以忍不住想和大家一起分享。")]),e._v(" "),a("p",[e._v("OK，我们直接进入正题。")]),e._v(" "),a("h2",{attrs:{id:"为什么要谈ast-抽象语法树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要谈ast-抽象语法树"}},[e._v("#")]),e._v(" 为什么要谈AST（抽象语法树）?")]),e._v(" "),a("p",[e._v("如果你查看目前任何主流的项目中的"),a("code",[e._v("devDependencies")]),e._v("，会发现前些年的不计其数的插件诞生。我们归纳一下有：javascript转译、代码压缩、css预处理器、elint、pretiier，等。有很多js模块我们不会在生产环境用到，但是它们在我们的开发过程中充当着重要的角色。所有的上述工具，不管怎样，都建立在了AST这个巨人的肩膀上。\n"),a("a",{attrs:{href:"https://user-images.githubusercontent.com/17001245/49001027-6a8fd680-f196-11e8-9f19-acc0c9f21284.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:r(525),alt:"image"}}),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("所有的上述工具，不管怎样，都建立在了AST这个巨人的肩膀上")]),e._v(" "),a("p",[e._v("我们定一个小目标，从解释什么是AST开始，然后到怎么从一般代码开始去构建它。我们将简单地接触在AST处理基础上，一些最流行的使用例子和工具。并且，我计划谈下我的js2flowchart项目，它是一个不错的利用AST的demo。OK，让我们开始吧。\n"),a("a",{attrs:{href:"https://user-images.githubusercontent.com/17001245/49001571-fce4aa00-f197-11e8-84cc-9571508f77f4.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:r(526),alt:"image"}}),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("什么是AST（抽象语法树）？")]),e._v(" "),a("blockquote",[a("p",[e._v("It is a hierarchical program representation that presents source code structure according to the grammar of a programming language, each AST node corresponds to an item of a source code.")])]),e._v(" "),a("p",[e._v("估计很多同学看完这段官方的定义会一脸懵逼。OK，我们来看例子：\n"),a("a",{attrs:{href:"https://user-images.githubusercontent.com/17001245/49001922-0e7a8180-f199-11e8-9817-9e5d509f4901.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:r(527),alt:"image"}}),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("这很简化")]),e._v(" "),a("p",[e._v("实际上，真正AST每个节点会有更多的信息。但是，这是大体思想。从纯文本中，我们将得到树形结构的数据。每个条目和树中的节点一一对应。")]),e._v(" "),a("p",[e._v("那怎么从纯文本中得到AST呢？哇哦，我们知道当下的编译器都做了这件事情。那我们就看看一般的编译器怎么做的就可以了。\n"),a("a",{attrs:{href:"https://user-images.githubusercontent.com/17001245/49002250-0c64f280-f19a-11e8-8dc2-2e87e4d200fe.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:r(528),alt:"image"}}),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("想做一款编译器是个比较消耗发量的事情，但幸运的是，我们无需贯穿编译器的所有知识点，最后将高级语言转译为二进制代码。我们只需要关注词法分析和语法分析。这两步是从代码中生成AST的关键所在。")]),e._v(" "),a("p",[e._v("第一步，词法分析，也叫做扫描scanner。它读取我们的代码，然后把它们按照预定的规则合并成一个个的标识tokens。同时，它会移除空白符，注释，等。最后，整个代码将被分割进一个tokens列表（或者说一维数组）。\n"),a("a",{attrs:{href:"https://user-images.githubusercontent.com/17001245/49002755-66b28300-f19b-11e8-907b-013a565d944b.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:r(529),alt:"image"}}),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("当词法分析源代码的时候，它会一个一个字母地读取代码，所以很形象地称之为扫描-scans；当它遇到空格，操作符，或者特殊符号的时候，它会认为一个话已经完成了。")]),e._v(" "),a("p",[e._v("第二步，语法分析，也解析器。它会将词法分析出来的数组转化成树形的表达形式。同时，验证语法，语法如果有错的话，抛出语法错误。\n"),a("a",{attrs:{href:"https://user-images.githubusercontent.com/17001245/49003444-e260ff80-f19c-11e8-997a-38a5a4ebeb7c.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:r(530),alt:"image"}}),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("当生成树的时候，解析器会删除一些没必要的标识tokens（比如不完整的括号），因此AST不是100%与源码匹配的，但是已经能让我们知道如何处理了。说个题外话，解析器100%覆盖所有代码结构生成树叫做CST（具体语法树）")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://user-images.githubusercontent.com/17001245/49004115-89926680-f19e-11e8-95b7-aad5e7fdf83b.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:r(531),alt:"image"}}),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("我们最终得到的")]),e._v(" "),a("p",[e._v("想要学习更多关于编译器的知识？\n"),a("a",{attrs:{href:"https://github.com/jamiebuilds/the-super-tiny-compiler",target:"_blank",rel:"noopener noreferrer"}},[e._v("the-super-tiny-compiler"),a("OutboundLink")],1),e._v("，一个贼好的项目。大概200来行代码，几乎每行都有注释。\n"),a("a",{attrs:{href:"https://user-images.githubusercontent.com/17001245/49004764-fc501180-f19f-11e8-8242-7140fabbf5f2.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:r(532),alt:"image"}}),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("想要自己创建门编程语言？\n"),a("a",{attrs:{href:"https://github.com/ftomassetti/LangSandbox",target:"_blank",rel:"noopener noreferrer"}},[e._v("LangSandbox"),a("OutboundLink")],1),e._v("，一个更好的项目。它演示了如何创造一门编程语言。当然，设计编程语言这样的书市面上也一坨坨。所以，这项目上一个相比更加深入，与"),a("a",{attrs:{href:"https://github.com/jamiebuilds/the-super-tiny-compiler",target:"_blank",rel:"noopener noreferrer"}},[e._v("the-super-tiny-compiler"),a("OutboundLink")],1),e._v("的项目将Lisp转为C语言不同，这个项目你可以写一个你自己的语言，并且将它编译成C语言或者机器语言，最后运行它。")]),e._v(" "),a("p",[e._v("我能直接用三方库来生成AST吗？\n当然可以！有一坨坨的三方库可以用。你可以访问"),a("a",{attrs:{href:"https://astexplorer.net/",target:"_blank",rel:"noopener noreferrer"}},[e._v("astexplorer"),a("OutboundLink")],1),e._v("，然后挑你喜欢的库。astexplorer是一个很棒的网站，你可以在线玩转AST，而且除了js，还有很多其它语言的AST库。\n"),a("a",{attrs:{href:"https://user-images.githubusercontent.com/17001245/49005590-0e32b400-f1a2-11e8-8d94-a501140a187f.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:r(533),alt:"image"}}),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("我不得不强调一款我觉得很棒的三方库，叫做babylon。\n"),a("a",{attrs:{href:"https://user-images.githubusercontent.com/17001245/49005704-5225b900-f1a2-11e8-8083-3c73464d5a78.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:r(534),alt:"image"}}),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("它被用在大名鼎鼎的babel中，也许这也是它之所以这么火的原因。因为有babel项目的支持，我们可以意料到它将与时俱进，一直支持最新的JS特性，因此可以放心大胆地用，不怕以后JS又出新版导致代码的大规模重构。另外，它的API也非常的简单，容易使用。")]),e._v(" "),a("p",[e._v("Ok，现在你知道怎么将代码生成AST了，让我们继续，来看看现实中的用例。")]),e._v(" "),a("p",[e._v("第一个用例，我想谈谈代码转化，没错，就是那个货，babel。")]),e._v(" "),a("blockquote",[a("p",[e._v("Babel is not a ‘tool for having ES6 support’. Well, it is, but it is far not only what it is about.")])]),e._v(" "),a("p",[e._v("经常把beble和支持es6/7/8联系起来，实际上，这也是我们经常用它的原因。但是，它仅仅是一组插件。我们也可以使用它来压缩代码，react相关语法转译（如jsx），flow插件等。\n"),a("a",{attrs:{href:"https://user-images.githubusercontent.com/17001245/49010480-4fc95c00-f1ae-11e8-8aa6-097d16c1c2db.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:r(535),alt:"image"}}),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("babel是一个javascript编译器。宏观来说，它分3个阶段运行代码：解析（parsing），转译（transforming），生成（generation）。我们可以给babel 一些javascript代码，它修改代码然后生成新的代码返回。那它是怎样修改代码的呢？没错！它创建了AST，遍历树，修改tokens，最后从AST中生成新的代码。")]),e._v(" "),a("p",[e._v("我们来从下面的demo中看下这个过程：\n"),a("a",{attrs:{href:"https://user-images.githubusercontent.com/17001245/49010863-7936b780-f1af-11e8-88f8-1ab083f3eafe.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:r(536),alt:"image"}}),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("像我之前提到的，babel使用babylon，所以，首先，我们解析代码成AST，然后遍历AST，再反转所有的变量名，最后生成代码。完成！正如我们看到的，第一步（解析）和第三步（生成）看起来很常规，我们每次都会做这两步。所以，babel接管处理了它俩。最后，我们最为关心的，那就是AST转译这一步了。")]),e._v(" "),a("p",[e._v("当我们开发babel-plugin的时候，我们只需要描述转化你AST的节点“visitors”就可以了。\n"),a("a",{attrs:{href:"https://user-images.githubusercontent.com/17001245/49011369-25c56900-f1b1-11e8-8ce8-69c5218ad0d1.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:r(537),alt:"image"}}),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("将它加入你的babel插件列表中，设置你webpack的babel-loader配置或者.babelrc中的plugins即可")]),e._v(" "),a("p",[e._v("如果你想要学习怎么创建你的第一个babel-plugin，可以查看"),a("a",{attrs:{href:"https://github.com/jamiebuilds/babel-handbook",target:"_blank",rel:"noopener noreferrer"}},[e._v("Babel-handbook"),a("OutboundLink")],1),e._v(" "),a("a",{attrs:{href:"https://user-images.githubusercontent.com/17001245/49011621-daf82100-f1b1-11e8-93d1-8da5567c8279.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:r(538),alt:"image"}}),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("让我们继续，下一个用例，我想提到的是自动代码重构工具，以及神器JSCodeshift。")]),e._v(" "),a("p",[e._v("比如说你想要替换掉所有的老掉牙的匿名函数，把他们变成Lambda表达式（箭头函数）。\n"),a("a",{attrs:{href:"https://user-images.githubusercontent.com/17001245/49011944-daac5580-f1b2-11e8-89b4-edff1b2f7a1e.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:r(539),alt:"image"}}),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("你的代码编辑器很可能没法这么做，因为这并不是简单地查找替换操作。这时候jscodeshift就登场了。")]),e._v(" "),a("p",[e._v("如果你听过"),a("code",[e._v("jscodeshift")]),e._v("，你很可能也听过"),a("code",[e._v("codemods")]),e._v("，一开始挺这两个词可能很困惑，不过没关系，接下来就解释。jscodeshift是一个跑"),a("code",[e._v("codemods")]),e._v("的工具。"),a("code",[e._v("codemod")]),e._v("是一段描述AST要转化成什么样的代码，这思想和babel的插件如出一辙。\n"),a("a",{attrs:{href:"https://user-images.githubusercontent.com/17001245/49012281-e8aea600-f1b3-11e8-9c30-84b2dd3b5d8b.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:r(540),alt:"image"}}),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("所以，如果你想创建自动把你的代码从旧的框架迁移到新的框架，这就是一种很乃思的方式。举个例子，react 16的prop-types重构。\n"),a("a",{attrs:{href:"https://user-images.githubusercontent.com/17001245/49012449-6ecaec80-f1b4-11e8-8435-7e4e9776b049.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:r(541),alt:"image"}}),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("有很多不同的"),a("code",[e._v("codemodes")]),e._v("已经创建了，你可以保存你需要的，以免手动的修改一坨坨代码，拿去挥霍吧：\nhttps://github.com/facebook/jscodeshift\nhttps://github.com/reactjs/react-codemod\n"),a("a",{attrs:{href:"https://user-images.githubusercontent.com/17001245/49012604-dc771880-f1b4-11e8-855a-1bbb56a676b2.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:r(542),alt:"image"}}),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("最后一个用例，我想要提到Prettier，因为可能每个码农都在日常工作中用到它。\n"),a("a",{attrs:{href:"https://user-images.githubusercontent.com/17001245/49012781-6f17b780-f1b5-11e8-832c-a6fb001c7cea.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:r(543),alt:"image"}}),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("Prettier 格式化我们的代码。它调整长句，整理空格，括号等。所以它将代码作为输入，修改后的代码作为输出。听起来很熟悉是吗？当然！\n"),a("a",{attrs:{href:"https://user-images.githubusercontent.com/17001245/49012911-eb11ff80-f1b5-11e8-9787-e89074659389.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:r(544),alt:"image"}}),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("思路还是一样。首先，将代码生成AST。之后依然是处理AST，最后生成代码。但是，中间过程其实并不像它看起来那么简单。")]),e._v(" "),a("p",[e._v("同样，如果你想学习更多在美化打印背后理论，这里有一本你可以深入的书 "),a("a",{attrs:{href:"http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("《A prettier printer》"),a("OutboundLink")],1),e._v("。\n"),a("a",{attrs:{href:"https://user-images.githubusercontent.com/17001245/49023266-cfb4ed80-f1d1-11e8-9834-5cb94708ce8c.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:r(545),alt:"image"}}),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("文章迎来尾声，我们继续，今天最后一件事，我想提及的就是我的库，叫做"),a("code",[e._v("js2flowchart")]),e._v("(4.5 k stars 在 Github)。\n"),a("a",{attrs:{href:"https://user-images.githubusercontent.com/17001245/49024698-0f310900-f1d5-11e8-9ecf-cbc478cc1518.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:r(546),alt:"image"}}),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("顾名思义，它将js代码转化生成svg流程图")]),e._v(" "),a("p",[e._v("这是一个很好的例子，因为它向你展现了你，当你拥有AST时，可以做任何你想要做的事。把AST转回成字符串代码并不是必要的，你可以通过它画一个流程图，或者其它你想要的东西。")]),e._v(" "),a("p",[e._v("js2flowchart使用场景是什么呢？通过流程图，你可以解释你的代码，或者给你代码写文档；通过可视化的解释学习其他人的代码；通过简单的js语法，为每个处理过程简单的描述创建流程图。")]),e._v(" "),a("p",[e._v("马上用最简单的方式尝试一下吧，去线上编辑看看 "),a("a",{attrs:{href:"https://bogdan-lyashenko.github.io/js-code-to-svg-flowchart/docs/live-editor/index.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("js-code-to-svg-flowchart"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("你也可以在代码中使用它，或者通过CLI，你只需要指向你想生成SVG的文件就行。而且，还有VS Code插件（链接在项目readme中）")]),e._v(" "),a("p",[e._v("那么，它还能做什么呢？哇哦，我这里就不废话了，大家有兴趣直接看这个项目的文档吧。")]),e._v(" "),a("p",[e._v("OK，那它是如何工作的呢？\n"),a("img",{attrs:{src:r(547),alt:"image"}})]),e._v(" "),a("p",[e._v("首先，解析代码成AST，然后，我们遍历AST并且生成另一颗树，我称之为工作流树。它删除很多不重要的额tokens，但是将关键块放在一起，如函数、循环、条件等。再之后，我们遍历工作流树并且创建形状树。每个形状树的节点包含可视化类型、位置、在树中的连接等信息。最后一步，我们遍历所有的形状，生成对应的SVG，合并所有的SVG到一个文件中。")]),e._v(" "),a("h2",{attrs:{id:"结尾"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#结尾"}},[e._v("#")]),e._v(" 结尾")]),e._v(" "),a("p",[e._v("寻找和筛选资料着实辛苦，希望同学们可以多多支持！")])])}),[],!1,null,null,null);t.default=n.exports}}]);